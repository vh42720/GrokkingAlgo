"""
Question #1: Write a function which returns the largest positive number
that can be generated by rearranging the digits of another positive number.
Example: 1001
Result:  1100
"""

def largest_pos(nums: int):
	digits = list(str(nums))
	digits.sort(reverse=True)

	return int(''.join(digits))

def largest_pos_opt(nums: int):
	count = [0] * 10
	for digit in str(nums):
		count[int(digit)] += 1

	result = []
	for i in range(len(count)-1, -1, -1):
		result.append(str(i)*count[i])
	return int(''.join(result))

# print(largest_pos(1001))
# print(largest_pos_opt(1001))

"""

Question #2: Given a mapping between book titles and the themes they contain,
find the theme which appears the most times.
If multiple themes appear the same number of times, return any one of them.
Example: {
"The Time Machine": ["Time travel", "Rebuilding civilization", "Language barriers"],
"The Danger Trail": ["Redemption",  "Rebuilding civilization"],
"Success Story":    ["Hope"],
}
Result: "Rebuilding civilization"

"""
books = {
"The Time Machine": ["Time travel", "Rebuilding civilization", "Language barriers"],
"The Danger Trail": ["Redemption",  "Rebuilding civilization"],
"Success Story":    ["Hope"],
}
def most_common(books:list):
	theme_dict = {}
	for book, themes in books.items():
		for theme in themes:
			theme_dict[theme] = theme_dict.get(theme, 0) + 1

	return max(theme_dict, key=theme_dict.get) if theme_dict else None

# print(most_common(books))

"""

The bookstore hosted a set of meetings across 24 hours.
Question #3: Given a list of meetings with the hours they started and ended at (as
numbers from 1 to 24), and the size of their audience, return the largest total number
of people that attended meetings simultaneously, across a continuous period of time.
Example: [
Meeting(title = "The Age of Fiction",   audience = 10, start = 1, end = 4),
Meeting(title = "Audiobook Publishing", audience = 20, start = 3, end = 8),
Meeting(title = "National Novel Month", audience = 30, start = 5, end = 8),
]
Result: 50
Explanation: The largest number of people attended between 5:00 and 8:00,
when the last two meetings were taking place at the same time.
"""
M = [
	("The Age of Fiction", 10, 1, 4),
	("Audiobook Publishing", 20, 3, 8),
	("National Novel Month", 30, 5, 8),
	("National Novel Month", 20, 3, 6)
]

def largest_guest_count(meetings:list):

	events = []
	for meeting in meetings:
		_, guests, start, end = meeting
		events.append((start, guests))
		events.append((end, -guests))
	events.sort(key=lambda x: (x[0], x[1]))

	current_max = max_count = 0
	for event in events:
		current_max += event[1]
		max_count = max(current_max, max_count)

	return max_count

# print(largest_guest_count(M))

"""

Other possible questions:
1. Given a list of shelves; [2, 4, 3, 6], where each value corresponds to the width of each shelf. Given a list of books width: [3, 1，2]. Ask if you can put all books onto the shelves. Every shelf can only hold one book.
2. Given a dictionary: {1: [2,3, 4], 2: [4, 5]....}, every key-value pair indicates that someone sent a friend invite to others ( i.e. user 1 sent invites to user 2，3，4) 
Questions: find the users who are N edges away from the customers who didn't receive any invite.
3. Smallest Odd : Create the smallest odd number from an integer
4. Consecutive Year Classes: Given a list of courses, determine the maximum number of classes held in two consecutive years. 
Input example: `Course(id=chemistry, class_per_year=4, start=2010, end=2014) Course(id=math, class_per_year=2, start=2008, end=2012)`
"""
print('\n+++++++++++++++++\nBook Shelves\n+++++++++++++++++')

def hold_shelves(shelves, books):
	if len(books) > len(shelves):
		return False

	books.sort()
	shelves.sort()

	shelf_index = 0
	for book in books:
		while book > shelves[shelf_index] and shelf_index < len(shelves):
			shelf_index += 1
		if shelf_index == len(shelves):
			return False
		shelf_index += 1
	return True


# print(hold_shelves([2, 4, 3, 6], [3, 1,2]))

print('\n+++++++++++++++++\nsmallest_odd\n+++++++++++++++++')

def smallest_odd(nums: int):
	digits = list(str(nums))
	digits.sort()

	if all(int(i)%2 == 0 for i in digits):
		return -1

	if int(digits[-1]) %2 == 1:
		return int(''.join(digits))

	for i in range(len(digits)-2 ,-1, -1):
		if int(digits[i]) % 2==1:
			digits[i], digits[-1] = digits[-1], digits[i]
			break

	return int(''.join(digits))


# print(214, smallest_odd(214))
# print(135, smallest_odd(135))
# print(46021, smallest_odd(46021))
# print(222, smallest_odd(222))

print('\n+++++++++++++++++\nConsecutive K years\n+++++++++++++++++')
C = [
	('chemistry', 4, 2010, 2014),
	('math', 2, 2008, 2012),
	('history', 2, 2007, 2013)
]


def max_courses_in_K_consecutive_years(courses:list, K):
	year_course = {}
	for course in courses:
		_, num, start, end = course
		for i in range(start, end+1, 1):
			year_course[i] = year_course.get(i, 0) + num

	years = year_course.keys()
	timeline = [year_course.get(year, 0) for year in range(min(years), max(years)+1, 1)]

	max_concurrent = current = sum(timeline[:K])
	for i in range(K, len(timeline)):
		current += timeline[i] - timeline[i-K]
		max_concurrent = max(max_concurrent, current)

	return max_concurrent


print(max_courses_in_K_consecutive_years(C, 2))

'''
def max_classes_in_K_consecutive_years(courses, K):
	year_classes = {}

	for _class in courses:
		for year in range(_class[2], _class[3]+1, 1):
			year_classes[year] = year_classes.get(year, 0) + _class[1]

	# sliding window of 2 years
	years = sorted(year_classes.keys())

	max_sum = 0
	for i in range(len(years) - 1):
		current_sum = year_classes.get(years[i]) + year_classes.get(years[i+1])
		max_sum = max(max_sum, current_sum)

	return max_sum


def max_classes_in_K_consecutive_years_normalized(courses, K):
	year_classes = {}
	for course in courses:
		for year in range(course[2], course[3] + 1):
			year_classes[year] = year_classes.get(year, 0) + course[1]

	# Get the full range of years.
	start_year = min(year_classes)
	end_year = max(year_classes)

	# Build a contiguous list of class counts for every year in that range.
	timeline = [year_classes.get(year, 0) for year in range(start_year, end_year + 1)]

	# Now use a sliding window on the contiguous timeline.
	window_sum = sum(timeline[:K])
	max_sum = window_sum
	for i in range(K, len(timeline)):
		window_sum += timeline[i] - timeline[i - K]
		max_sum = max(max_sum, window_sum)

	return max_sum
'''



